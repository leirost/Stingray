
Program ::= {Import} {Declaration}

Import ::= 'import' identifier {'.' identifier} 'as' identifier

Declaration ::= 'declare' identifier as TypeReference

TypeReference ::= 'Nothing' | identifier | FunctionDeclarationType | FunctionDefinitionType | ClassType
TypeReference ::= identifier '[]'

FunctionDeclarationType ::= FunctionRangeDomain '->' FunctionRangeDomain
FunctionDefinitionType  ::= NamedFunctionRange '->' FunctionRangeDomain Body
FunctionRangeDomain     ::= TypeReference | '(' [TypeReference {',' TypeReference}] ')'
NamedFunctionRange      ::= TypeReference identifier | '(' [TypeReference identifier {',' TypeReference identifier}] ')'

ClassType        ::= [ExtendsList] ['(' StaticsBody ')'] '{' [ClassBody] '}'
ExtendsList      ::= {identifier} (identifier | 'class' | 'interface')
StaticsBody      ::= FieldDefinition {FieldDefinition}
ClassBody        ::= {FieldDefinition}

FieldDefinition  ::= identifier [':' TypeReference] [Value]
Value            ::= '<-' Expression | '{' Expression '}'
Body             ::= '{' {Statement} '}'

Statement        ::= identifier [':' TypeReference] [Value]
                   | IfStatement
                   | 'while' Expression Body
                   | 'for' identifier 'in' RangeExpr Body
                   | 'return' Expression

IfStatement     ::= 'if' Expression Body ['else' (IfStatement | Body)]

LambdaExpression ::= NamedFunctionRange '->' (Expression | Body) 
                   | '(' [identifier {',' identifier}] ')' -> (Expression | Body)

MethodReference  ::= identifier '::' identifier # done

Expression ::= Unop Expression # done
             | Term [Binop Term] # done
             | LambdaExpression 
             | MethodReference # done
ArrayRef     ::= Term '[' Expression ']' # done
FunctionCall ::= Term '(' [Expression {',' Expression}] ')' # done
FieldRef     ::= Term '.' identifier # done
Term         ::= '(' Expression ')' # done
               | ArrayRef # done
               | FunctionCall #done
               | FieldRef # done
               | ('true' | 'false' | 'empty') # done
               | (numeric | string | identifier) # done
               | '[' [Expression {',' Expression}] ']' # done
               | RangeExpr # done

RangeOpening    ::= '[' | '(' # done
RangeClosing    ::= ']' | ')' # done
RangeExpr       ::= RangeOpening Expression ';' Expression RangeClosing [':' Expression] # done

Unop    ::= '#' | '-' | 'not'
Binop   ::= '=' | '!=' | '<' | '>' | '<=' | '>=' | '+' | '-' | '*' | '/' | '%' | '^' | 'and' | 'xor' | 'or' | '=>' | '<=>' 
          | 'is' # Now not implemented